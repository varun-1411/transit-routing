
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algorithms.TRANSFER_PATTERNS.transferpattern_func &#8212; Transit-routing Pending documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Transit-routing Pending documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Algorithms.TRANSFER_PATTERNS.transferpattern_func</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Algorithms.TRANSFER_PATTERNS.transferpattern_func</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module contains function related to transfer patterns, scalable transfer patterns</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>


<div class="viewcode-block" id="initialize_onemany_tbtr"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.initialize_onemany_tbtr">[docs]</a><span class="k">def</span> <span class="nf">initialize_onemany_tbtr</span><span class="p">(</span><span class="n">MAX_TRANSFER</span><span class="p">,</span> <span class="n">DESTINATION_LIST</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Initialize values for one-to-many TBTR.</span>

<span class="sd">    Args:</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>
<span class="sd">        DESTINATION_LIST (list): list of stop ids of destination stop.</span>

<span class="sd">    Returns:</span>
<span class="sd">        J (dict): dict to store arrival timestamps. Keys: number of transfer, Values: arrival time.</span>
<span class="sd">        inf_time (pandas.datetime): Variable indicating infinite time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#    inf_time = pd.to_datetime(&quot;today&quot;).round(freq=&#39;H&#39;) + pd.to_timedelta(&quot;365 day&quot;)</span>
    <span class="n">inf_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s2">&quot;2023-01-26 20:00:00&quot;</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="p">{</span><span class="n">desti</span><span class="p">:</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">inf_time</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span> <span class="k">for</span> <span class="n">desti</span> <span class="ow">in</span> <span class="n">DESTINATION_LIST</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">J</span><span class="p">,</span> <span class="n">inf_time</span></div>


<div class="viewcode-block" id="initialize_from_desti_onemany_tbtr"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.initialize_from_desti_onemany_tbtr">[docs]</a><span class="k">def</span> <span class="nf">initialize_from_desti_onemany_tbtr</span><span class="p">(</span><span class="n">routes_by_stop_dict</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">,</span> <span class="n">DESTINATION_LIST</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">,</span> <span class="n">idx_by_route_stop_dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Initialize routes/footpath to leading to destination stop in case of one-to-many rTBTR</span>

<span class="sd">    Args:</span>
<span class="sd">        routes_by_stop_dict (dict): preprocessed dict. Format {stop_id: [id of routes passing through stop]}.</span>
<span class="sd">        stops_dict (dict): preprocessed dict. Format {route_id: [ids of stops in the route]}.</span>
<span class="sd">        DESTINATION_LIST (list): list of stop ids of destination stop.</span>
<span class="sd">        footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">        idx_by_route_stop_dict (dict): preprocessed dict. Format {(route id, stop id): stop index in route}.</span>

<span class="sd">    Returns:</span>
<span class="sd">        L (nested dict): A dict to track routes/leading to destination stops. Key: route_id, value: {destination_stop_id: [(from_stop_idx, travel time, stop id)]}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">L_dict_final</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">DESTINATION_LIST</span><span class="p">:</span>
        <span class="n">L_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">transfer_to_desti</span> <span class="o">=</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">from_stop</span><span class="p">,</span> <span class="n">foot_time</span> <span class="ow">in</span> <span class="n">transfer_to_desti</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">walkalble_desti_route</span> <span class="o">=</span> <span class="n">routes_by_stop_dict</span><span class="p">[</span><span class="n">from_stop</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">walkalble_desti_route</span><span class="p">:</span>
                        <span class="n">L_dict</span><span class="p">[</span><span class="n">route</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx_by_route_stop_dict</span><span class="p">[(</span><span class="n">route</span><span class="p">,</span> <span class="n">from_stop</span><span class="p">)],</span> <span class="n">foot_time</span><span class="p">,</span> <span class="n">from_stop</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">delta_tau</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;seconds&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="p">[</span><span class="n">destination</span><span class="p">]:</span>
            <span class="n">L_dict</span><span class="p">[</span><span class="n">route</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx_by_route_stop_dict</span><span class="p">[(</span><span class="n">route</span><span class="p">,</span> <span class="n">destination</span><span class="p">)],</span> <span class="n">delta_tau</span><span class="p">,</span> <span class="n">destination</span><span class="p">))</span>
        <span class="n">L_dict_final</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">L_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L_dict_final</span></div>


<div class="viewcode-block" id="update_label_tbtr"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.update_label_tbtr">[docs]</a><span class="k">def</span> <span class="nf">update_label_tbtr</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">no_of_transfer</span><span class="p">,</span> <span class="n">predecessor_label</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Updates and returns destination pareto set.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (pandas.datetime): optimal arrival time .</span>
<span class="sd">        no_of_transfer (int): number of transfer.</span>
<span class="sd">        predecessor_label (tuple): predecessor_label for backtracking (To be developed)</span>
<span class="sd">        J (dict): dict to store arrival timestamps. Keys: number of transfer, Values: arrival time</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>

<span class="sd">    Returns:</span>
<span class="sd">        J (dict): dict to store arrival timestamps. Keys: number of transfer, Values: arrival time</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">J</span><span class="p">[</span><span class="n">no_of_transfer</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">predecessor_label</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_of_transfer</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">J</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">label</span><span class="p">:</span>
            <span class="n">J</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
    <span class="k">return</span> <span class="n">J</span></div>


<div class="viewcode-block" id="initialize_from_source_range_tbtr"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.initialize_from_source_range_tbtr">[docs]</a><span class="k">def</span> <span class="nf">initialize_from_source_range_tbtr</span><span class="p">(</span><span class="n">dep_details</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">R_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Initialize trips segments from source in rTBTR</span>

<span class="sd">    Args:</span>
<span class="sd">        dep_details (list): list of format [trip id, departure time, source index]</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        R_t (nested dict): Nested_Dict with primary keys as trip id and secondary keys as number of transfers. Format {trip_id: {[round]: first reached stop}}</span>

<span class="sd">    Returns:</span>
<span class="sd">        Q (list): list of trips segments</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="n">route</span><span class="p">,</span> <span class="n">trip_idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dep_details</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
    <span class="n">stop_index</span> <span class="o">=</span> <span class="n">dep_details</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># _enqueue_range1(f&#39;{route}_{trip_idx}&#39;, stop_index, n, (0, 0), R_t, Q, stoptimes_dict, MAX_TRANSFER)</span>
    <span class="n">connection_list</span> <span class="o">=</span> <span class="p">[(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">route</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">trip_idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">stop_index</span><span class="p">)]</span>
    <span class="n">enqueue_range_tbtr</span><span class="p">(</span><span class="n">connection_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R_t</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Q</span></div>


<div class="viewcode-block" id="enqueue_range_tbtr"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.enqueue_range_tbtr">[docs]</a><span class="k">def</span> <span class="nf">enqueue_range_tbtr</span><span class="p">(</span><span class="n">connection_list</span><span class="p">,</span> <span class="n">nextround</span><span class="p">,</span> <span class="n">predecessor_label</span><span class="p">,</span> <span class="n">R_t</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    adds trips-segments to next round round and update R_t. Used in range queries</span>

<span class="sd">    Args:</span>
<span class="sd">        connection_list (list): list of connections to be added. Format: [(to_trip_id, to_trip_id_stop_index)].</span>
<span class="sd">        nextround (int): next round/transfer number to which trip-segments are added</span>
<span class="sd">        predecessor_label (tuple): predecessor_label for backtracking journey ( To be developed ).</span>
<span class="sd">        R_t (nested dict): Nested_Dict with primary keys as trip id and secondary keys as number of transfers. Format {trip_id: {[round]: first reached stop}}</span>
<span class="sd">        Q (list): list of trips segments</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>

<span class="sd">    Returns: None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">to_trip_id</span><span class="p">,</span> <span class="n">to_trip_id_stop</span> <span class="ow">in</span> <span class="n">connection_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">to_trip_id_stop</span> <span class="o">&lt;</span> <span class="n">R_t</span><span class="p">[</span><span class="n">nextround</span><span class="p">][</span><span class="n">to_trip_id</span><span class="p">]:</span>
            <span class="n">route</span><span class="p">,</span> <span class="n">tid</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">to_trip_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">nextround</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">to_trip_id_stop</span><span class="p">,</span> <span class="n">to_trip_id</span><span class="p">,</span> <span class="n">R_t</span><span class="p">[</span><span class="n">nextround</span><span class="p">][</span><span class="n">to_trip_id</span><span class="p">],</span> <span class="n">route</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">predecessor_label</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">route</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nextround</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">new_tid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">route</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">R_t</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">new_tid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">to_trip_id_stop</span><span class="p">:</span>
                        <span class="n">R_t</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">new_tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_trip_id_stop</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="post_process_range_onemany_tbtr"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.post_process_range_onemany_tbtr">[docs]</a><span class="k">def</span> <span class="nf">post_process_range_onemany_tbtr</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">rounds_desti_reached</span><span class="p">,</span> <span class="n">PRINT_ITINERARY</span><span class="p">,</span> <span class="n">desti</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">,</span>
                                    <span class="n">stops_dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">d_time</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">,</span> <span class="n">trip_transfer_dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Contains all the post-processing features for One-To-Many rTBTR.</span>
<span class="sd">    Currently supported functionality:</span>
<span class="sd">        Collect list of trips needed to cover pareto-optimal journeys.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (dict): dict to store arrival timestamps. Keys: number of transfer, Values: arrival time</span>
<span class="sd">        Q (list): list of trips segments.</span>
<span class="sd">        rounds_desti_reached (list): Rounds in which DESTINATION is reached.</span>
<span class="sd">        desti (int): destination stop id.</span>

<span class="sd">    Returns:</span>
<span class="sd">        TBTR_out (set): Trips needed to cover pareto-optimal journeys.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">rounds_desti_reached</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rounds_desti_reached</span><span class="p">))</span>
    <span class="n">TP</span> <span class="o">=</span> <span class="n">_print_tbtr_journey_otm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">desti</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">d_time</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">,</span> <span class="n">trip_transfer_dict</span><span class="p">,</span> <span class="n">rounds_desti_reached</span><span class="p">,</span>
                                 <span class="n">PRINT_ITINERARY</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TP</span></div>


<span class="k">def</span> <span class="nf">_print_tbtr_journey_otm</span><span class="p">(</span><span class="n">J</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                            <span class="n">D_TIME</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">trip_transfer_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">rounds_desti_reached</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">PRINT_ITINERARY</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prints the output of TBTR</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">         J (dict): dict to store arrival timestamps. Keys: number of transfer, Values: arrival time</span>
<span class="sd">         Q (list): list of trips segments.</span>
<span class="sd">         DESTINATION (int): stop id of destination stop.</span>
<span class="sd">         SOURCE (int): stop id of source stop.</span>
<span class="sd">         footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">         stops_dict (dict): preprocessed dict. Format {route_id: [ids of stops in the route]}.</span>
<span class="sd">         stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">         D_TIME (pandas.datetime): departure time.</span>
<span class="sd">         MAX_TRANSFER (int): maximum transfer limit.</span>
<span class="sd">         trip_transfer_dict (nested dict): keys: id of trip we are transferring from, value: {stop number: list of tuples</span>
<span class="sd">         rounds_desti_reached (list): Rounds in which DESTINATION is reached.</span>
<span class="sd">         PRINT_ITINERARY (int): 1 or 0. 1 means print complete path.            </span>

<span class="sd">    Returns:</span>
<span class="sd">         TP_list (list): list of transfer patterns</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TP_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">rounds_desti_reached</span><span class="p">):</span>
        <span class="n">round_no</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">journey</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trip_segement_counter</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">round_no</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">round_no</span><span class="p">][</span><span class="n">trip_segement_counter</span><span class="p">]</span>
            <span class="n">journey</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pred</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pred</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">trip_segement_counter</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">round_no</span> <span class="o">=</span> <span class="n">round_no</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">from_stop_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">t_transfer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">journey</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">from_Stop_onwards</span> <span class="o">=</span> <span class="n">journey</span><span class="p">[</span><span class="nb">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">from_stop</span><span class="p">,</span> <span class="n">trasnsfer_list</span> <span class="ow">in</span> <span class="n">trip_transfer_dict</span><span class="p">[</span><span class="n">t_transfer</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">from_stop</span> <span class="o">&lt;</span> <span class="n">from_Stop_onwards</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">t_transfer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t_transfer</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="ow">in</span> <span class="n">trasnsfer_list</span><span class="p">:</span>
                        <span class="n">from_stop_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_stop</span><span class="p">)</span>
        <span class="n">journey_final</span> <span class="o">=</span> <span class="p">[(</span><span class="n">journey</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">journey</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">journey</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">from_stop_list</span><span class="p">)]</span>
        <span class="c1"># from source</span>
        <span class="n">from_trip</span><span class="p">,</span> <span class="n">from_stop_idxx</span> <span class="o">=</span> <span class="n">journey</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">journey</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fromstopid</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">from_trip</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])][</span><span class="n">from_stop_idxx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fromstopid</span> <span class="o">==</span> <span class="n">SOURCE</span><span class="p">:</span>
            <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;trip&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">from_trip</span><span class="p">,</span> <span class="n">from_stop_idxx</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">to_stop</span><span class="p">,</span> <span class="n">to_time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">fromstopid</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">to_stop</span> <span class="o">==</span> <span class="n">SOURCE</span><span class="p">:</span>
                    <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;walk&quot;</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">,</span> <span class="n">fromstopid</span><span class="p">,</span> <span class="n">to_time</span> <span class="o">+</span> <span class="n">D_TIME</span><span class="p">))</span>
                    <span class="k">break</span>
        <span class="c1"># Add final lag. Destination can either be along the route or at a walking distance from it.</span>
        <span class="k">if</span> <span class="n">J</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># Add here if the destination is at walking distance from final route</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">final_route</span><span class="p">,</span> <span class="n">boarded_from</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">walking_from_stop_idx</span><span class="p">,</span> <span class="n">stop_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stops_dict</span><span class="p">[</span><span class="n">final_route</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">walking_from_stop_idx</span> <span class="o">&lt;</span> <span class="n">boarded_from</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">to_stop</span><span class="p">,</span> <span class="n">to_stop_time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">stop_id</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">to_stop</span> <span class="o">==</span> <span class="n">DESTINATION</span><span class="p">:</span>
                                <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="n">journey_final</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;walk&quot;</span><span class="p">,</span> <span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">boarded_from</span><span class="p">,</span> <span class="n">walking_from_stop_idx</span><span class="p">,</span>
                                                         <span class="n">to_stop_time</span><span class="p">))</span>  <span class="c1"># walking_pointer, from_trip, from_stop, to_stop</span>
                                <span class="k">break</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">journey_final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">final_route</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">boarded_from</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">final_route</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">walking_from_stop_idx</span><span class="p">,</span> <span class="n">stop_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stops_dict</span><span class="p">[</span><span class="n">final_route</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">walking_from_stop_idx</span> <span class="o">&lt;</span> <span class="n">boarded_from</span><span class="p">:</span> <span class="k">continue</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">to_stop</span><span class="p">,</span> <span class="n">to_stop_time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">stop_id</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">to_stop</span> <span class="o">==</span> <span class="n">DESTINATION</span><span class="p">:</span>
                                    <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span>
                                    <span class="n">journey_final</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;walk&quot;</span><span class="p">,</span> <span class="n">J</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">boarded_from</span><span class="p">,</span> <span class="n">walking_from_stop_idx</span><span class="p">,</span>
                                                             <span class="n">to_stop_time</span><span class="p">))</span>  <span class="c1"># walking_pointer, from_trip, from_stop, to_stop</span>
                                    <span class="k">break</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NameError</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Destination is along the route.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">final_route</span><span class="p">,</span> <span class="n">boarded_from</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">desti_index</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">final_route</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">DESTINATION</span><span class="p">)</span>
                <span class="n">journey_final</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;trip&quot;</span><span class="p">,</span> <span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">boarded_from</span><span class="p">,</span> <span class="n">desti_index</span><span class="p">))</span>  <span class="c1"># walking_pointer, from_trip, from_stop, to_stop</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">journey_final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">final_route</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">boarded_from</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">final_route</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">journey_final</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">desti_index</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">final_route</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">DESTINATION</span><span class="p">)</span>
                    <span class="n">journey_final</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;trip&quot;</span><span class="p">,</span> <span class="n">J</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">boarded_from</span><span class="p">,</span> <span class="n">desti_index</span><span class="p">))</span>  <span class="c1"># walking_pointer, from_trip, from_stop, to_stop</span>
        <span class="k">if</span> <span class="n">journey_final</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">tid</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">journey</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
            <span class="n">tostop_det</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">tid</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">DESTINATION</span><span class="p">)</span>
            <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">journey</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">tid</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">tid</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">journey</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">tid</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">tid</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">tostop_det</span><span class="p">]))</span>
        <span class="n">journey_final</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">journey_final_copy</span> <span class="o">=</span> <span class="n">journey_final</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">journey_final</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">leg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;trip&quot;</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">trip_route</span><span class="p">,</span> <span class="n">numb</span><span class="p">],</span> <span class="n">fromstopidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]])</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span>
                                                  <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">stops_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">DESTINATION</span><span class="p">)]])</span>
                            <span class="k">break</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]]])</span>
                <span class="k">elif</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
                    <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;walk&quot;</span><span class="p">,</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">time</span> <span class="k">for</span> <span class="n">stop</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;trip&quot;</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">trip_route</span><span class="p">,</span> <span class="n">numb</span><span class="p">],</span> <span class="n">fromstopidx</span><span class="p">,</span> <span class="n">tostopidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">tostopidx</span><span class="p">]])</span>
                <span class="k">elif</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
                    <span class="n">from_trip</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
                    <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]]))</span>
                    <span class="n">foot_connect</span> <span class="o">=</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
                    <span class="n">last_foot_tme</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span> <span class="k">for</span> <span class="n">stop</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">foot_connect</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">DESTINATION</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="s2">&quot;walk&quot;</span><span class="p">,</span> <span class="n">foot_connect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DESTINATION</span><span class="p">,</span> <span class="n">last_foot_tme</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">from_trip</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">last_foot_tme</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">trip_route</span><span class="p">,</span> <span class="n">numb</span><span class="p">],</span> <span class="n">tostopidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">fromstopidx</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                        <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">tostopidx</span><span class="p">]])</span>
                    <span class="k">elif</span> <span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;trip&quot;</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">trip_route</span><span class="p">,</span> <span class="n">numb</span><span class="p">],</span> <span class="n">tostopidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">fromstopidx</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">tostopidx</span><span class="p">]]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">journey_final</span><span class="p">:</span>
                            <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">tostopidx</span><span class="p">]])</span>
                <span class="n">from_stop</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])][</span><span class="nb">int</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span>
                <span class="n">to_stop</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])][</span><span class="nb">int</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">3</span><span class="p">])]</span>
                <span class="k">if</span> <span class="n">from_stop</span> <span class="o">!=</span> <span class="n">to_stop</span><span class="p">:</span>
                    <span class="n">time_needed</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">from_stop</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">to_stop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;walk&quot;</span><span class="p">,</span> <span class="n">from_stop</span><span class="p">,</span> <span class="n">to_stop</span><span class="p">,</span> <span class="n">time_needed</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">trip_route</span><span class="p">,</span> <span class="n">numb</span><span class="p">],</span> <span class="n">fromstopidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]])</span>
                <span class="k">elif</span> <span class="n">from_stop</span> <span class="o">==</span> <span class="n">to_stop</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">journey_final_copy</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">trip_route</span><span class="p">,</span> <span class="n">numb</span><span class="p">],</span> <span class="n">fromstopidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="n">journey_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">fromstopidx</span><span class="p">],</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">numb</span><span class="p">][</span><span class="n">journey_final_copy</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]])</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">journey_final</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">PRINT_ITINERARY</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;from </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> walk till  </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
                <span class="n">TP</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">PRINT_ITINERARY</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;from </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> board at </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s2"> and get down on </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s2"> along </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">TP</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">TP_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">TP</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">PRINT_ITINERARY</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;####################################&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TP_list</span>


<div class="viewcode-block" id="onetomany_rtbtr_forhubs"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.onetomany_rtbtr_forhubs">[docs]</a><span class="k">def</span> <span class="nf">onetomany_rtbtr_forhubs</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">DESTINATION_LIST</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">d_time_groups</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">WALKING_FROM_SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">PRINT_ITINERARY</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">OPTIMIZED</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">routes_by_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                            <span class="n">footpath_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">idx_by_route_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">trip_transfer_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">trip_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">hubstops</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One to many rTBTR implementation. Connections are not added from the stops in hubstops set.</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        DESTINATION_LIST (list): list of stop ids of destination stop.</span>
<span class="sd">        d_time_groups (pandas.group): all possible departures times from all stops.</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>
<span class="sd">        WALKING_FROM_SOURCE (int): 1 or 0. 1 means walking from SOURCE is allowed.</span>
<span class="sd">        PRINT_ITINERARY (int): 1 or 0. 1 means print complete path.</span>
<span class="sd">        OPTIMIZED (int): 1 or 0. 1 means collect trips and 0 means collect routes.</span>
<span class="sd">        routes_by_stop_dict (dict): preprocessed dict. Format {stop_id: [id of routes passing through stop]}.</span>
<span class="sd">        stops_dict (dict): preprocessed dict. Format {route_id: [ids of stops in the route]}.</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">        idx_by_route_stop_dict (dict): preprocessed dict. Format {(route id, stop id): stop index in route}.</span>
<span class="sd">        trip_transfer_dict (nested dict): keys: id of trip we are transferring from, value: {stop number: list of tuples</span>
<span class="sd">        of form (id of trip we are transferring to, stop number)}</span>
<span class="sd">        trip_set (set): set of trip ids from which trip-transfers are available.</span>
<span class="sd">        hubstops (set): set containing id&#39;s of stop that are hubs</span>

<span class="sd">    Returns:</span>
<span class="sd">        if OPTIMIZED==1:</span>
<span class="sd">            out (list):  list of trips required to cover all optimal journeys Format: [trip_id]</span>
<span class="sd">        elif OPTIMIZED==0:</span>
<span class="sd">            out (list):  list of routes required to cover all optimal journeys. Format: [route_id]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DESTINATION_LIST</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">)</span>
    <span class="n">d_time_list</span> <span class="o">=</span> <span class="n">d_time_groups</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">)[[</span><span class="s2">&quot;trip_id&quot;</span><span class="p">,</span> <span class="s1">&#39;arrival_time&#39;</span><span class="p">,</span> <span class="s1">&#39;stop_sequence&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">WALKING_FROM_SOURCE</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">source_footpaths</span> <span class="o">=</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">source_footpaths</span><span class="p">:</span>
                <span class="n">d_time_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">d_time_groups</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">connection</span><span class="p">[</span><span class="mi">0</span><span class="p">])[[</span><span class="s2">&quot;trip_id&quot;</span><span class="p">,</span> <span class="s1">&#39;arrival_time&#39;</span><span class="p">,</span> <span class="s1">&#39;stop_sequence&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="n">d_time_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">TP_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">J</span><span class="p">,</span> <span class="n">inf_time</span> <span class="o">=</span> <span class="n">initialize_onemany_tbtr</span><span class="p">(</span><span class="n">MAX_TRANSFER</span><span class="p">,</span> <span class="n">DESTINATION_LIST</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">initialize_from_desti_onemany_tbtr</span><span class="p">(</span><span class="n">routes_by_stop_dict</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">,</span> <span class="n">DESTINATION_LIST</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">,</span> <span class="n">idx_by_route_stop_dict</span><span class="p">)</span>
    <span class="n">R_t</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)}</span>  <span class="c1"># assuming maximum route length is 1000</span>

    <span class="k">for</span> <span class="n">dep_details</span> <span class="ow">in</span> <span class="n">d_time_list</span><span class="p">:</span>
        <span class="n">rounds_desti_reached</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">DESTINATION_LIST</span><span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">initialize_from_source_range_tbtr</span><span class="p">(</span><span class="n">dep_details</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">R_t</span><span class="p">)</span>
        <span class="n">dest_list_prime</span> <span class="o">=</span> <span class="n">DESTINATION_LIST</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">MAX_TRANSFER</span><span class="p">:</span>
            <span class="n">stop_mark_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">stop</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">dest_list_prime</span><span class="p">}</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">trip_segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                <span class="n">from_stop</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">to_stop</span><span class="p">,</span> <span class="n">trip_route</span><span class="p">,</span> <span class="n">tid_idx</span> <span class="o">=</span> <span class="n">trip_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">5</span><span class="p">]</span>
                <span class="n">trip</span> <span class="o">=</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">tid_idx</span><span class="p">][</span><span class="n">from_stop</span><span class="p">:</span><span class="n">to_stop</span><span class="p">]</span>
                <span class="n">connection_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">desti</span> <span class="ow">in</span> <span class="n">dest_list_prime</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">L</span><span class="p">[</span><span class="n">desti</span><span class="p">][</span><span class="n">trip_route</span><span class="p">]</span>
                        <span class="n">stop_list</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">trip</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">last_leg</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">desti</span><span class="p">][</span><span class="n">trip_route</span><span class="p">]:</span>
                            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stop_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">last_leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="n">idx</span> <span class="ow">and</span> <span class="n">from_stop</span> <span class="o">&lt;</span> <span class="n">last_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">trip</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">last_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">J</span><span class="p">[</span><span class="n">desti</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">last_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;seconds&quot;</span><span class="p">):</span>
                                    <span class="n">walking</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">walking</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">trip_route</span><span class="p">][</span><span class="n">last_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                                <span class="n">J</span><span class="p">[</span><span class="n">desti</span><span class="p">]</span> <span class="o">=</span> <span class="n">update_label_tbtr</span><span class="p">(</span><span class="n">trip</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">last_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">walking</span><span class="p">,</span> <span class="n">counter</span><span class="p">),</span> <span class="n">J</span><span class="p">[</span><span class="n">desti</span><span class="p">],</span> <span class="n">MAX_TRANSFER</span><span class="p">)</span>
                                <span class="n">rounds_desti_reached</span><span class="p">[</span><span class="n">desti</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">trip_set</span> <span class="ow">and</span> <span class="n">trip</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">J</span><span class="p">[</span><span class="n">desti</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">stop_mark_dict</span><span class="p">[</span><span class="n">desti</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">scope</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">desti</span><span class="p">)</span>
                                <span class="n">stop_mark_dict</span><span class="p">[</span><span class="n">desti</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">connection_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">connection</span> <span class="k">for</span> <span class="n">from_stop_idx</span><span class="p">,</span> <span class="n">transfer_stop_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trip</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">from_stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">transfer_stop_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hubstops</span>
                                 <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">trip_transfer_dict</span><span class="p">[</span><span class="n">tid</span><span class="p">][</span><span class="n">from_stop_idx</span><span class="p">]])</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="n">connection_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">connection_list</span><span class="p">))</span>
                <span class="n">enqueue_range_tbtr</span><span class="p">(</span><span class="n">connection_list</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R_t</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">)</span>
            <span class="n">dest_list_prime</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">scope</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">desti</span> <span class="ow">in</span> <span class="n">DESTINATION_LIST</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rounds_desti_reached</span><span class="p">[</span><span class="n">desti</span><span class="p">]:</span>
                <span class="n">TP_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="n">post_process_range_onemany_tbtr</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">rounds_desti_reached</span><span class="p">[</span><span class="n">desti</span><span class="p">],</span> <span class="n">PRINT_ITINERARY</span><span class="p">,</span> <span class="n">desti</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">,</span>
                                                    <span class="n">stoptimes_dict</span><span class="p">,</span>
                                                    <span class="n">dep_details</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">MAX_TRANSFER</span><span class="p">,</span> <span class="n">trip_transfer_dict</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">TP_list</span></div>


<div class="viewcode-block" id="build_query_graph"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.build_query_graph">[docs]</a><span class="k">def</span> <span class="nf">build_query_graph</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">,</span> <span class="n">hub_count</span><span class="p">,</span> <span class="n">hubstops</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds the query graph for transfer patterns.</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        NETWORK_NAME (str): name of the network</span>
<span class="sd">        hub_count (int):  Number of hub stops</span>
<span class="sd">        hubstops (set): set containing id&#39;s of stop that are hubs</span>

<span class="sd">    Returns:</span>
<span class="sd">        adj_list (dist): adjacency list for the query graph</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./TRANSFER_PATTERNS/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">hub_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">SOURCE</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>  <span class="c1"># Unpickling</span>
        <span class="n">stored_transferpattern</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">hub</span> <span class="ow">in</span> <span class="n">hubstops</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./TRANSFER_PATTERNS/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">hub_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">hub</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>  <span class="c1"># Unpickling</span>
            <span class="n">stored_transferpattern</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>

    <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">stored_transferpattern</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
    <span class="n">adj_list</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]],</span> <span class="p">[],</span> <span class="p">[]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">generate_adjlist</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">))}</span>
    <span class="k">return</span> <span class="n">adj_list</span></div>


<div class="viewcode-block" id="build_query_graph_forSTP"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.build_query_graph_forSTP">[docs]</a><span class="k">def</span> <span class="nf">build_query_graph_forSTP</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">,</span> <span class="n">cluster_info</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds the query graph for scalable transfer patterns.</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        DESTINATION (int): stop id of destination stop.</span>
<span class="sd">                NETWORK_NAME (str): name of the network</span>
<span class="sd">        cluster_info:</span>

<span class="sd">    Returns:</span>
<span class="sd">        adj_list (dist): adjacency list for the query graph</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cluster_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_info</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">is_source_border</span><span class="p">,</span> <span class="n">is_desti_border</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cluster_count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">SOURCE</span> <span class="ow">in</span> <span class="n">cluster_info</span><span class="p">[</span><span class="n">cid</span><span class="p">]:</span>
            <span class="n">s_cid</span> <span class="o">=</span> <span class="n">cid</span>
    <span class="k">if</span> <span class="n">SOURCE</span> <span class="ow">in</span> <span class="n">cluster_info</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">is_source_border</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cluster_count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DESTINATION</span> <span class="ow">in</span> <span class="n">cluster_info</span><span class="p">[</span><span class="n">cid</span><span class="p">]:</span>
            <span class="n">d_cid</span> <span class="o">=</span> <span class="n">cid</span>
    <span class="k">if</span> <span class="n">DESTINATION</span> <span class="ow">in</span> <span class="n">cluster_info</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">is_desti_border</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">s_cid</span> <span class="o">==</span> <span class="n">d_cid</span> <span class="ow">or</span> <span class="n">is_desti_border</span> <span class="o">==</span> <span class="n">is_source_border</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./TRANSFER_PATTERNS/stp/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cluster_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">SOURCE</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">stored_transferpattern</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([(</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">stored_transferpattern</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>
    <span class="k">if</span> <span class="n">s_cid</span> <span class="o">!=</span> <span class="n">d_cid</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./TRANSFER_PATTERNS/stp/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cluster_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">SOURCE</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">stored_transferpattern</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([(</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">stored_transferpattern</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>
        <span class="n">border_stops_of_source</span> <span class="o">=</span> <span class="n">cluster_info</span><span class="p">[</span><span class="n">s_cid</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">bordernode</span> <span class="ow">in</span> <span class="n">border_stops_of_source</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./TRANSFER_PATTERNS/stp/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cluster_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">bordernode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([(</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>
                <span class="n">edge_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">border_stops_of_destination</span> <span class="o">=</span> <span class="n">cluster_info</span><span class="p">[</span><span class="n">d_cid</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">bordernode</span> <span class="ow">in</span> <span class="n">border_stops_of_destination</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./TRANSFER_PATTERNS/stp/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cluster_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">bordernode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([(</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>
                <span class="n">edge_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
    <span class="n">adj_list</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]],</span> <span class="p">[],</span> <span class="p">[]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">generate_adjlist</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">))}</span>
    <span class="k">return</span> <span class="n">adj_list</span></div>


<div class="viewcode-block" id="check_dominance"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.check_dominance">[docs]</a><span class="k">def</span> <span class="nf">check_dominance</span><span class="p">(</span><span class="n">t_l</span><span class="p">,</span> <span class="n">adjlist_dict</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the best values in both the criteria is dominated by destination</span>

<span class="sd">    Args:</span>
<span class="sd">        t_l (list): list of tuples of format: (arrival time, number of transfer, predecessor node id, index of label updated from, self node_id)</span>
<span class="sd">        adj_list (dist): adjacency list for the query graph</span>
<span class="sd">        DESTINATION (int): stop id of destination stop.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True or False (boolean)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">first_crit</span><span class="p">,</span> <span class="n">second_crit</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">t_l</span><span class="p">)</span>
    <span class="n">minimum_t_l</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">first_crit</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">second_crit</span><span class="p">)]</span>
    <span class="n">desti_critera</span> <span class="o">=</span> <span class="p">[(</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">desti_critera</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">minimum_t_l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">minimum_t_l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># print(&quot;Terminted early&quot;)</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="new_label_is_dominated"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.new_label_is_dominated">[docs]</a><span class="k">def</span> <span class="nf">new_label_is_dominated</span><span class="p">(</span><span class="n">new_label</span><span class="p">,</span> <span class="n">adjlist_dict</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the new_label dominates the destination label</span>

<span class="sd">    Args:</span>
<span class="sd">        new_label (list): list of tuples of format: (arrival time, number of transfer, predecessor node id, index of label updated from, self node_id)</span>
<span class="sd">        adj_list (dist): adjacency list for the query graph</span>
<span class="sd">        DESTINATION (int): stop id of destination stop.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True or False (boolean)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">desti_critera</span> <span class="o">=</span> <span class="p">[(</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">DESTINATION</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">desti_critera</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">new_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">new_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># print(&quot;label not evaluated&quot;)</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="multicriteria_dij_alternate"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.multicriteria_dij_alternate">[docs]</a><span class="k">def</span> <span class="nf">multicriteria_dij_alternate</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">D_TIME</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">routesindx_by_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                <span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">hub_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hubstops</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multicriteria Dijkstra&#39;s algorithm to be used in transfer patterns query phase. The implementation has been borrowed from NetworkX.</span>
<span class="sd">    This is untested-varient of Martin&#39;s algorithm</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        DESTINATION (int): stop id of destination stop.</span>
<span class="sd">        D_TIME (pandas.datetime): departure time.</span>
<span class="sd">        footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">                NETWORK_NAME (str): name of the network</span>
<span class="sd">        routesindx_by_stop_dict (dict): Keys: stop id, value: [(route_id, stop index), (route_id, stop index)]</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        hub_count (int):  Number of hub stops</span>
<span class="sd">        hubstops (set): set containing id&#39;s of stop that are hubs</span>

<span class="sd">    Returns:</span>
<span class="sd">        adj_list (dist): adjacency list for the query graph</span>

<span class="sd">    #TODO: Check correctness and efficiency</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adjlist_dict</span> <span class="o">=</span> <span class="n">build_query_graph</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">,</span> <span class="n">hub_count</span><span class="p">,</span> <span class="n">hubstops</span><span class="p">)</span>
    <span class="n">t_l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">init_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_TIME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">]</span>  <span class="c1"># criteria1, criteria2, pred_node_id, idx_predece_label, self.node_id</span>

    <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_label</span><span class="p">)</span>
    <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_label</span><span class="p">)</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">t_l</span> <span class="ow">and</span> <span class="n">check_dominance</span><span class="p">(</span><span class="n">t_l</span><span class="p">,</span> <span class="n">adjlist_dict</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">)):</span>
        <span class="c1"># while (t_l):</span>

        <span class="n">l_q</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_l</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Move l_q from temporary to permanent</span>
        <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>
        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>
        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>  <span class="c1"># Store the position of label l_q from l_pq</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Compute l_j the current label of vertex j</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr_time</span> <span class="o">=</span> <span class="n">arrivaltme_query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">routesindx_by_stop_dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># No trip avaliable after l_q[0]</span>
            <span class="n">l_j</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">arr_time</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

            <span class="c1"># Verify there is no label of j dominated by l_j</span>
            <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dominated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">dominated</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Store l_j as temporary label of j</span>
                <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                <span class="c1"># Delete all temporary labels of j dominated by l_j</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                        <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">footpath_time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
                <span class="n">l_j</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">l_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">footpath_time</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c1"># Verify there is no label of j dominated by l_j</span>
                <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">dominated</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">dominated</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="c1"># Store l_j as temporary label of j</span>
                    <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                    <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                    <span class="c1"># Delete all temporary labels of j dominated by l_j</span>
                    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                            <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">adjlist_dict</span></div>


<div class="viewcode-block" id="multicriteria_dij"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.multicriteria_dij">[docs]</a><span class="k">def</span> <span class="nf">multicriteria_dij</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">D_TIME</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">routesindx_by_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                      <span class="n">hub_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hubstops</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multicriteria Dijkstra&#39;s algorithm to be used in transfer patterns query phase. The implementation has been borrowed from NetworkX.</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        DESTINATION (int): stop id of destination stop.</span>
<span class="sd">        D_TIME (pandas.datetime): departure time.</span>
<span class="sd">        footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">                NETWORK_NAME (str): name of the network</span>
<span class="sd">        routesindx_by_stop_dict (dict): Keys: stop id, value: [(route_id, stop index), (route_id, stop index)]</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        hub_count (int):  Number of hub stops</span>
<span class="sd">        hubstops (set): set containing id&#39;s of stop that are hubs</span>

<span class="sd">    Returns:</span>
<span class="sd">        adj_list (dist): adjacency list for the query graph</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adjlist_dict</span> <span class="o">=</span> <span class="n">build_query_graph</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">,</span> <span class="n">hub_count</span><span class="p">,</span> <span class="n">hubstops</span><span class="p">)</span>
    <span class="n">t_l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">init_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_TIME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">]</span>  <span class="c1"># criteria1, criteria2, pred_node_id, idx_predece_label, self.node_id</span>

    <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_label</span><span class="p">)</span>
    <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_label</span><span class="p">)</span>

    <span class="c1"># while (t_l and check_dominance(t_l, adjlist_dict, DESTINATION)):</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">t_l</span><span class="p">):</span>

        <span class="n">l_q</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_l</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Move l_q from temporary to permanent</span>
        <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>
        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>
        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_label_is_dominated</span><span class="p">(</span><span class="n">l_q</span><span class="p">,</span> <span class="n">adjlist_dict</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>  <span class="c1"># Store the position of label l_q from l_pq</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Compute l_j the current label of vertex j</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr_time</span> <span class="o">=</span> <span class="n">arrivaltme_query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">routesindx_by_stop_dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># No trip avaliable after l_q[0]</span>
            <span class="n">l_j</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">arr_time</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

            <span class="c1"># Verify there is no label of j dominated by l_j</span>
            <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dominated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">dominated</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Store l_j as temporary label of j</span>
                <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                <span class="c1"># Delete all temporary labels of j dominated by l_j</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                        <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">footpath_time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
                <span class="n">l_j</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">l_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">footpath_time</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c1"># Verify there is no label of j dominated by l_j</span>
                <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">dominated</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">dominated</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="c1"># Store l_j as temporary label of j</span>
                    <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                    <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                    <span class="c1"># Delete all temporary labels of j dominated by l_j</span>
                    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                            <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">adjlist_dict</span></div>


<div class="viewcode-block" id="multicriteria_dij_forSTP"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.multicriteria_dij_forSTP">[docs]</a><span class="k">def</span> <span class="nf">multicriteria_dij_forSTP</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">D_TIME</span><span class="p">,</span> <span class="n">footpath_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">routesindx_by_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                             <span class="n">cluster_info</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multicriteria Dijkstra&#39;s algorithm to be used in scalable transfer patterns query phase. The implementation has been borrowed from NetworkX.</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        DESTINATION (int): stop id of destination stop.</span>
<span class="sd">        D_TIME (pandas.datetime): departure time.</span>
<span class="sd">        footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">                NETWORK_NAME (str): name of the network</span>
<span class="sd">        routesindx_by_stop_dict (dict): Keys: stop id, value: [(route_id, stop index), (route_id, stop index)]</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        cluster_info:</span>

<span class="sd">    Returns:</span>
<span class="sd">        adj_list (dist): adjacency list for the query graph</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adjlist_dict</span> <span class="o">=</span> <span class="n">build_query_graph_forSTP</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">,</span> <span class="n">DESTINATION</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">,</span> <span class="n">cluster_info</span><span class="p">)</span>
    <span class="n">t_l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">init_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_TIME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">]</span>  <span class="c1"># criteria1, criteria2, pred_node_id, idx_predece_label, self.node_id</span>

    <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_label</span><span class="p">)</span>
    <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_label</span><span class="p">)</span>
    <span class="c1"># adjlist_dict[33991]</span>
    <span class="k">while</span> <span class="n">t_l</span><span class="p">:</span>
        <span class="n">l_q</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_l</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Move l_q from temporary to permanent</span>
        <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>
        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>
        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l_q</span><span class="p">)</span>  <span class="c1"># Store the position of label l_q from l_pq</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Compute l_j the current label of vertex j</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr_time</span> <span class="o">=</span> <span class="n">arrivaltme_query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">routesindx_by_stop_dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># No trip avaliable after l_q[0]</span>
            <span class="n">l_j</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">arr_time</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

            <span class="c1"># Verify there is no label of j dominated by l_j</span>
            <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dominated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">dominated</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Store l_j as temporary label of j</span>
                <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                <span class="c1"># Delete all temporary labels of j dominated by l_j</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                        <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">footpath_time</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
                <span class="n">l_j</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">l_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">footpath_time</span><span class="p">,</span> <span class="n">l_q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c1"># Verify there is no label of j dominated by l_j</span>
                <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">dominated</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">dominated</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="c1"># Store l_j as temporary label of j</span>
                    <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                    <span class="n">t_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_j</span><span class="p">)</span>
                    <span class="c1"># Delete all temporary labels of j dominated by l_j</span>
                    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">adjlist_dict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                            <span class="n">t_l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">adjlist_dict</span></div>


<div class="viewcode-block" id="arrivaltme_query"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.arrivaltme_query">[docs]</a><span class="k">def</span> <span class="nf">arrivaltme_query</span><span class="p">(</span><span class="n">stop1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">stop2</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">deptime</span><span class="p">,</span> <span class="n">routesindx_by_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the earliest trip departing from stop 1 after deptime and going to stop 2.</span>

<span class="sd">    Args:</span>
<span class="sd">        stop1 (int): Stop id</span>
<span class="sd">        stop2 (int): Stop id</span>
<span class="sd">        deptime (pandas.datetime):</span>
<span class="sd">        routesindx_by_stop_dict (dict): Keys: stop id, value: [(route_id, stop index), (route_id, stop index)]</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.datetime object</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">routeidx1</span><span class="p">,</span> <span class="n">routeidx2</span> <span class="o">=</span> <span class="n">routesindx_by_stop_dict</span><span class="p">[</span><span class="n">stop1</span><span class="p">],</span> <span class="n">routesindx_by_stop_dict</span><span class="p">[</span><span class="n">stop2</span><span class="p">]</span>
    <span class="n">comon_routes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">routeidx1</span><span class="p">,</span> <span class="n">routeidx2</span><span class="p">)</span> <span class="k">if</span> <span class="n">seq1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">seq1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">arrival_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iternary</span> <span class="ow">in</span> <span class="n">comon_routes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">trip_idx</span><span class="p">,</span> <span class="n">trip</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">iternary</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]):</span>
            <span class="k">if</span> <span class="n">trip</span><span class="p">[</span><span class="n">iternary</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">deptime</span><span class="p">:</span>
                <span class="n">arrival_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trip</span><span class="p">[</span><span class="n">iternary</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_brutehubs"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.get_brutehubs">[docs]</a><span class="k">def</span> <span class="nf">get_brutehubs</span><span class="p">(</span><span class="n">routes_by_stop_dict</span><span class="p">,</span> <span class="n">NETWORK_NAME</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select hubs using brute force. This is Naive implementation that can be used to test the effectiveness of the hubs. The idea is to generate</span>
<span class="sd">    full transfer patterns (without hubs) and then use optimal paths to find hub stops.</span>

<span class="sd">    Args:</span>
<span class="sd">        routes_by_stop_dict (dict): preprocessed dict. Format {stop_id: [id of routes passing through stop]}.</span>
<span class="sd">                NETWORK_NAME (str): name of the network</span>

<span class="sd">    Returns:</span>
<span class="sd">        global_count (list): list of tuples of format: (stop_id, number of optimal paths it stop_id is belongs to)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">global_count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span>
    <span class="k">for</span> <span class="n">stop_id</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./TRANSFER_PATTERNS/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s2">_0/</span><span class="si">{</span><span class="n">stop_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>  <span class="c1"># Unpickling</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
        <span class="n">global_count</span> <span class="o">=</span> <span class="n">global_count</span> <span class="o">+</span> <span class="n">temp</span>
    <span class="n">global_count</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">global_count</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">hub_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">hubs</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">global_count</span><span class="p">[:</span><span class="n">hubs</span><span class="p">]]</span> <span class="k">for</span> <span class="n">hubs</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">1600</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">6400</span><span class="p">,</span> <span class="mi">12800</span><span class="p">]}</span>
    <span class="n">hub_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;./TRANSFER_PATTERNS/</span><span class="si">{</span><span class="n">NETWORK_NAME</span><span class="si">}</span><span class="s1">_hub_brute.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pickle_file</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">hub_dict</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">global_count</span></div>


<div class="viewcode-block" id="onetoall_rraptor_forhubs"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.onetoall_rraptor_forhubs">[docs]</a><span class="k">def</span> <span class="nf">onetoall_rraptor_forhubs</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">DESTINATION_LIST</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">d_time_groups</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">WALKING_FROM_SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">CHANGE_TIME_SEC</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">PRINT_ITINERARY</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">OPTIMIZED</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">routes_by_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stops_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                             <span class="n">footpath_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">idx_by_route_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">hubstops</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-To-Many rRAPTOR implementation. Trips are not scanned from the stops in hubstops set.</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        DESTINATION_LIST (list): list of stop ids of destination stop.</span>
<span class="sd">        d_time_groups (pandas.group): all possible departures times from all stops.</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>
<span class="sd">        WALKING_FROM_SOURCE (int): 1 or 0. 1 means walking from SOURCE is allowed.</span>
<span class="sd">        CHANGE_TIME_SEC (int): change-time in seconds.</span>
<span class="sd">        PRINT_ITINERARY (int): 1 or 0. 1 means print complete path.</span>
<span class="sd">        OPTIMIZED (int): 1 or 0. 1 means collect trips and 0 means collect routes.</span>
<span class="sd">        routes_by_stop_dict (dict): preprocessed dict. Format {stop_id: [id of routes passing through stop]}.</span>
<span class="sd">        stops_dict (dict): preprocessed dict. Format {route_id: [ids of stops in the route]}.</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">        idx_by_route_stop_dict (dict): preprocessed dict. Format {(route id, stop id): stop index in route}.</span>
<span class="sd">        hubstops (set): set containing id&#39;s of stop that are hubs</span>

<span class="sd">    Returns:</span>
<span class="sd">        if OPTIMIZED==1:</span>
<span class="sd">            out (list):  list of trips required to cover all optimal journeys Format: [trip_id]</span>
<span class="sd">        elif OPTIMIZED==0:</span>
<span class="sd">            out (list):  list of routes required to cover all optimal journeys. Format: [route_id]</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; output = onetomany_rraptor(36, [52, 43], pd.to_datetime(&#39;2019-06-10 00:00:00&#39;), 4, 1, 0, 1, 0, routes_by_stop_dict, stops_dict, stoptimes_dict, footpath_dict, idx_by_route_stop_dict)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">DESTINATION_LIST</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="c1"># d_time_list is list tuples. Format = [(trip_id, arrival time, stop index)]</span>
    <span class="n">d_time_list</span> <span class="o">=</span> <span class="n">d_time_groups</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">)[[</span><span class="s2">&quot;trip_id&quot;</span><span class="p">,</span> <span class="s1">&#39;arrival_time&#39;</span><span class="p">,</span> <span class="s1">&#39;stop_sequence&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">WALKING_FROM_SOURCE</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">source_footpaths</span> <span class="o">=</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">source_footpaths</span><span class="p">:</span>
                <span class="n">d_time_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">d_time_groups</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">connection</span><span class="p">[</span><span class="mi">0</span><span class="p">])[[</span><span class="s2">&quot;trip_id&quot;</span><span class="p">,</span> <span class="s1">&#39;arrival_time&#39;</span><span class="p">,</span> <span class="s1">&#39;stop_sequence&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="n">d_time_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">star_label</span><span class="p">,</span> <span class="n">inf_time</span> <span class="o">=</span> <span class="n">initialize_raptor</span><span class="p">(</span><span class="n">routes_by_stop_dict</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">)</span>
    <span class="n">change_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">CHANGE_TIME_SEC</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;seconds&#39;</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dep_details</span> <span class="ow">in</span> <span class="n">d_time_list</span><span class="p">:</span>
        <span class="n">pi_label</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">{</span><span class="n">stop</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">marked_stop</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">marked_stop_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">stop</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">start_tid</span><span class="p">,</span> <span class="n">d_time</span><span class="p">,</span> <span class="n">s_idx</span> <span class="o">=</span> <span class="n">dep_details</span>
        <span class="n">first_stop</span> <span class="o">=</span> <span class="n">stops_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start_tid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])][</span><span class="n">s_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">first_stop</span> <span class="o">!=</span> <span class="n">SOURCE</span><span class="p">:</span>
            <span class="n">marked_stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_stop</span><span class="p">)</span>
            <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">first_stop</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">to_pdash_time</span> <span class="o">=</span> <span class="p">[</span><span class="n">foot_connect</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">foot_connect</span> <span class="ow">in</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">]</span> <span class="k">if</span> <span class="n">foot_connect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">first_stop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">first_stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_time</span> <span class="o">-</span> <span class="n">change_time</span>
            <span class="n">star_label</span><span class="p">[</span><span class="n">first_stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_time</span> <span class="o">-</span> <span class="n">change_time</span>
            <span class="n">pi_label</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">first_stop</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;walking&#39;</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">,</span> <span class="n">first_stop</span><span class="p">,</span> <span class="n">to_pdash_time</span><span class="p">,</span> <span class="n">d_time</span> <span class="o">-</span> <span class="n">change_time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">marked_stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">)</span>
            <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">SOURCE</span><span class="p">],</span> <span class="n">star_label</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_time</span><span class="p">,</span> <span class="n">d_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PRINT_ITINERARY</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">,</span> <span class="n">d_time</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Main code part 1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

            <span class="n">Q</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>  <span class="c1"># Format of Q is {route:stop}</span>
            <span class="k">while</span> <span class="n">marked_stop</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">marked_stop</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">Q</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start_tid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">s_idx</span>
                    <span class="k">break</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">routes_serving_p</span> <span class="o">=</span> <span class="n">routes_by_stop_dict</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">routes_serving_p</span><span class="p">:</span>
                        <span class="n">stp_idx</span> <span class="o">=</span> <span class="n">idx_by_route_stop_dict</span><span class="p">[(</span><span class="n">route</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">Q</span><span class="p">[</span><span class="n">route</span><span class="p">]</span> <span class="o">!=</span> <span class="n">stp_idx</span><span class="p">:</span>
                            <span class="n">Q</span><span class="p">[</span><span class="n">route</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stp_idx</span><span class="p">,</span> <span class="n">Q</span><span class="p">[</span><span class="n">route</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">Q</span><span class="p">[</span><span class="n">route</span><span class="p">]</span> <span class="o">=</span> <span class="n">stp_idx</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="c1"># Main code part 2</span>
            <span class="k">for</span> <span class="n">route</span><span class="p">,</span> <span class="n">current_stopindex_by_route</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">current_trip_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">p_i</span> <span class="ow">in</span> <span class="n">stops_dict</span><span class="p">[</span><span class="n">route</span><span class="p">][</span><span class="n">current_stopindex_by_route</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">current_trip_t</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">current_trip_t</span><span class="p">[</span><span class="n">current_stopindex_by_route</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">star_label</span><span class="p">[</span><span class="n">p_i</span><span class="p">]:</span>
                        <span class="n">arr_by_t_at_pi</span> <span class="o">=</span> <span class="n">current_trip_t</span><span class="p">[</span><span class="n">current_stopindex_by_route</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p_i</span><span class="p">],</span> <span class="n">star_label</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_by_t_at_pi</span><span class="p">,</span> <span class="n">arr_by_t_at_pi</span>
                        <span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boarding_time</span><span class="p">,</span> <span class="n">boarding_point</span><span class="p">,</span> <span class="n">p_i</span><span class="p">,</span> <span class="n">arr_by_t_at_pi</span><span class="p">,</span> <span class="n">tid</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">p_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hubstops</span><span class="p">:</span>
                                <span class="n">marked_stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_i</span><span class="p">)</span>
                                <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">current_trip_t</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">label</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">p_i</span><span class="p">]</span> <span class="o">+</span> <span class="n">change_time</span> <span class="o">&lt;</span> <span class="n">current_trip_t</span><span class="p">[</span><span class="n">current_stopindex_by_route</span><span class="p">][</span>
                        <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># assuming arrival_time = departure_time</span>
                        <span class="n">tid</span><span class="p">,</span> <span class="n">current_trip_t</span> <span class="o">=</span> <span class="n">get_latest_trip_new</span><span class="p">(</span><span class="n">stoptimes_dict</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">p_i</span><span class="p">],</span> <span class="n">current_stopindex_by_route</span><span class="p">,</span> <span class="n">change_time</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">current_trip_t</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">boarding_time</span><span class="p">,</span> <span class="n">boarding_point</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">boarding_point</span> <span class="o">=</span> <span class="n">p_i</span>
                            <span class="n">boarding_time</span> <span class="o">=</span> <span class="n">current_trip_t</span><span class="p">[</span><span class="n">current_stopindex_by_route</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">current_stopindex_by_route</span> <span class="o">=</span> <span class="n">current_stopindex_by_route</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Main code part 3</span>
            <span class="n">marked_stop_copy</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">marked_stop</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">marked_stop_copy</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">trans_info</span> <span class="o">=</span> <span class="n">footpath_dict</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trans_info</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">p_dash</span><span class="p">,</span> <span class="n">to_pdash_time</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">new_p_dash_time</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="n">to_pdash_time</span>
                        <span class="k">if</span> <span class="n">new_p_dash_time</span> <span class="o">&lt;</span> <span class="n">star_label</span><span class="p">[</span><span class="n">p_dash</span><span class="p">]:</span>
                            <span class="n">label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p_dash</span><span class="p">],</span> <span class="n">star_label</span><span class="p">[</span><span class="n">p_dash</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_p_dash_time</span><span class="p">,</span> <span class="n">new_p_dash_time</span>
                            <span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p_dash</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;walking&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p_dash</span><span class="p">,</span> <span class="n">to_pdash_time</span><span class="p">,</span> <span class="n">new_p_dash_time</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">p_dash</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">p_dash</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hubstops</span><span class="p">:</span>
                                    <span class="n">marked_stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_dash</span><span class="p">)</span>
                                    <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">p_dash</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="c1"># Main code End</span>
            <span class="k">if</span> <span class="n">marked_stop</span> <span class="o">==</span> <span class="n">deque</span><span class="p">([]):</span>
                <span class="c1"># print(&#39;code ended with termination condition&#39;)</span>
                <span class="k">break</span>
        <span class="n">output</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">post_processing_onetoall_rraptor</span><span class="p">(</span><span class="n">DESTINATION_LIST</span><span class="p">,</span> <span class="n">pi_label</span><span class="p">,</span> <span class="n">PRINT_ITINERARY</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">OPTIMIZED</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">PRINT_ITINERARY</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="get_latest_trip_new"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.get_latest_trip_new">[docs]</a><span class="k">def</span> <span class="nf">get_latest_trip_new</span><span class="p">(</span><span class="n">stoptimes_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">route</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arrival_time_at_pi</span><span class="p">,</span> <span class="n">pi_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">change_time</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get latest trip after a certain timestamp from the given stop of a route.</span>

<span class="sd">    Args:</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        route (int): id of route.</span>
<span class="sd">        arrival_time_at_pi (pandas.datetime): arrival time at stop pi.</span>
<span class="sd">        pi_index (int): index of the stop from which route was boarded.</span>
<span class="sd">        change_time (pandas.datetime): change time at stop (set to 0).</span>

<span class="sd">    Returns:</span>
<span class="sd">        If a trip exists:</span>
<span class="sd">            trip index, trip</span>
<span class="sd">        else:</span>
<span class="sd">            -1,-1   (e.g. when there is no trip after the given timestamp)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; output = get_latest_trip_new(stoptimes_dict, 1000, pd.to_datetime(&#39;2019-06-10 17:40:00&#39;), 0, pd.to_timedelta(0, unit=&#39;seconds&#39;))</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">trip_idx</span><span class="p">,</span> <span class="n">trip</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">route</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">trip</span><span class="p">[</span><span class="n">pi_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arrival_time_at_pi</span> <span class="o">+</span> <span class="n">change_time</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">route</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">trip_idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">stoptimes_dict</span><span class="p">[</span><span class="n">route</span><span class="p">][</span><span class="n">trip_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># No trip is found after arrival_time_at_pi</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># No trip exsist for this route. in this case check tripid from trip file for this route and then look waybill.ID. Likely that trip is across days thats why it is rejected in stoptimes builder while checking</span></div>


<div class="viewcode-block" id="initialize_raptor"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.initialize_raptor">[docs]</a><span class="k">def</span> <span class="nf">initialize_raptor</span><span class="p">(</span><span class="n">routes_by_stop_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Initialize values for RAPTOR.</span>

<span class="sd">    Args:</span>
<span class="sd">        routes_by_stop_dict (dict): preprocessed dict. Format {stop_id: [id of routes passing through stop]}.</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>

<span class="sd">    Returns:</span>
<span class="sd">        marked_stop (deque): deque to store marked stop.</span>
<span class="sd">        marked_stop_dict (dict): Binary variable indicating if a stop is marked. Keys: stop Id, value: 0 or 1.</span>
<span class="sd">        label (dict): nested dict to maintain label. Format {round : {stop_id: pandas.datetime}}.</span>
<span class="sd">        pi_label (dict): Nested dict used for backtracking labels. Format {round : {stop_id: pointer_label}}</span>
<span class="sd">        if stop is reached by walking, pointer_label= (&#39;walking&#39;, from stop id, to stop id, time, arrival time)}} else pointer_label= (trip boarding time, boarding_point, stop id, arr_by_trip, trip id)</span>
<span class="sd">        star_label (dict): dict to maintain best arrival label {stop id: pandas.datetime}.</span>
<span class="sd">        inf_time (pd.timestamp): Variable indicating infinite time (pandas.datetime).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; output = initialize_raptor(routes_by_stop_dict, 20775, 4)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">inf_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s2">&quot;today&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="s2">&quot;365 day&quot;</span><span class="p">)</span>
    <span class="c1">#    inf_time = pd.to_datetime(&#39;2022-01-15 19:00:00&#39;)</span>

    <span class="n">pi_label</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">{</span><span class="n">stop</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
    <span class="n">label</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">{</span><span class="n">stop</span><span class="p">:</span> <span class="n">inf_time</span> <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
    <span class="n">star_label</span> <span class="o">=</span> <span class="p">{</span><span class="n">stop</span><span class="p">:</span> <span class="n">inf_time</span> <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

    <span class="n">marked_stop</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">marked_stop_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">stop</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">routes_by_stop_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="n">marked_stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SOURCE</span><span class="p">)</span>
    <span class="n">marked_stop_dict</span><span class="p">[</span><span class="n">SOURCE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">marked_stop</span><span class="p">,</span> <span class="n">marked_stop_dict</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pi_label</span><span class="p">,</span> <span class="n">star_label</span><span class="p">,</span> <span class="n">inf_time</span></div>


<div class="viewcode-block" id="post_processing_onetoall_rraptor"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.post_processing_onetoall_rraptor">[docs]</a><span class="k">def</span> <span class="nf">post_processing_onetoall_rraptor</span><span class="p">(</span><span class="n">DESTINATION_LIST</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">pi_label</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">PRINT_ITINERARY</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">OPTIMIZED</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    post processing for Ont-To-Many rRAPTOR. Currently supported functionality:</span>
<span class="sd">        1. Print the output</span>
<span class="sd">        2. Routes required for covering pareto-optimal set.</span>
<span class="sd">        3. Trips required for covering pareto-optimal set.</span>

<span class="sd">    Args:</span>
<span class="sd">        DESTINATION_LIST (list): list of stop ids of destination stop.</span>
<span class="sd">        pi_label (dict): Nested dict used for backtracking. Primary keys: Round, Secondary keys: stop id. Format- {round : {stop_id: pointer_label}}</span>
<span class="sd">        PRINT_ITINERARY (int): 1 or 0. 1 means print complete path.</span>
<span class="sd">        label (dict): nested dict to maintain label. Format {round : {stop_id: pandas.datetime}}.</span>
<span class="sd">        OPTIMIZED (int): 1 or 0. 1 means collect trips and 0 means collect routes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        if OPTIMIZED==1:</span>
<span class="sd">            final_trips (list): list of trips required to cover all pareto-optimal journeys. format - [trip_id]</span>
<span class="sd">        elif OPTIMIZED==0:</span>
<span class="sd">            final_routes (list): list of routes required to cover all pareto-optimal journeys. format - [route_id]</span>


<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; output = post_processing_onetomany_rraptor([1482], pi_label, 1, label, 0)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">TP_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">DESTINATION</span> <span class="ow">in</span> <span class="n">DESTINATION_LIST</span><span class="p">:</span>
        <span class="n">rounds_inwhich_desti_reached</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pi_label</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">pi_label</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">DESTINATION</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rounds_inwhich_desti_reached</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="n">PRINT_ITINERARY</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;DESTINATION cannot be reached with given MAX_TRANSFERS&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rounds_inwhich_desti_reached</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">pareto_set</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">trip_set</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># rap_out = [label[k][DESTINATION] for k in rounds_inwhich_desti_reached]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rounds_inwhich_desti_reached</span><span class="p">:</span>
                <span class="n">transfer_needed</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">journey</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">DESTINATION</span>
                <span class="k">while</span> <span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">stop</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">journey</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">stop</span><span class="p">])</span>
                    <span class="n">mode</span> <span class="o">=</span> <span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">stop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;walking&#39;</span><span class="p">:</span>
                        <span class="n">stop</span> <span class="o">=</span> <span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">stop</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">trip_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">stop</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">stop</span> <span class="o">=</span> <span class="n">pi_label</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">stop</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">journey</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">pareto_set</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">transfer_needed</span><span class="p">,</span> <span class="n">journey</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">PRINT_ITINERARY</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_print_Journey_legs</span><span class="p">(</span><span class="n">pareto_set</span><span class="p">)</span>
            <span class="n">TP_list_desti</span> <span class="o">=</span> <span class="n">extract_transferpattern</span><span class="p">(</span><span class="n">pareto_set</span><span class="p">)</span>
            <span class="n">TP_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">TP_list_desti</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TP_list</span></div>


<span class="k">def</span> <span class="nf">_print_Journey_legs</span><span class="p">(</span><span class="n">pareto_journeys</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Prints journey in correct format. Parent Function: post_processing</span>

<span class="sd">    Args:</span>
<span class="sd">        pareto_journeys (list): pareto optimal set.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; output = _print_Journey_legs(pareto_journeys)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">journey</span> <span class="ow">in</span> <span class="n">pareto_journeys</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">journey</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;walking&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;from </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> walk till  </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>
            <span class="c1">#                print(f&#39;from {leg[1]} walk till  {leg[2]} for {leg[3]} minutes and reach at {leg[4].time()}&#39;)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;from </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> board at </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s1"> and get down on </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1"> at </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s1"> along </span><span class="si">{</span><span class="n">leg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;####################################&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="extract_transferpattern"><a class="viewcode-back" href="../../../Algorithms/Transfer_patterns/transferpattern_func.html#Algorithms.TRANSFER_PATTERNS.transferpattern_func.extract_transferpattern">[docs]</a><span class="k">def</span> <span class="nf">extract_transferpattern</span><span class="p">(</span><span class="n">pareto_journeys</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Extract transfer patterns from pareto_journeys</span>

<span class="sd">    Args:</span>
<span class="sd">        pareto_journeys (list): pareto optimal set.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pareto_journeys (list): list of stop sequence transfer patterns</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">TP_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">journey</span> <span class="ow">in</span> <span class="n">pareto_journeys</span><span class="p">:</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">journey</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;walking&#39;</span><span class="p">:</span>
                <span class="n">TP</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">TP</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">leg</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
        <span class="n">TP_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">TP</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">TP_list</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">################################</span>
<span class="sd">Depreciated functions</span>
<span class="sd">################################</span>


<span class="sd">def post_process_range(J, Q, rounds_desti_reached, PRINT_ITINERARY, DESTINATION, SOURCE, footpath_dict, stops_dict, stoptimes_dict, d_time, MAX_TRANSFER,</span>
<span class="sd">                       trip_transfer_dict) -&gt; set:</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="sd">    Contains all the post-processing features for rTBTR.</span>
<span class="sd">    Currently supported functionality:</span>
<span class="sd">        Collect list of trips needed to cover pareto-optimal journeys.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (dict): dict to store arrival timestamps. Keys: number of transfer, Values: arrival time</span>
<span class="sd">        Q (list): list of trips segments.</span>
<span class="sd">        rounds_desti_reached (list): Rounds in which DESTINATION is reached.</span>

<span class="sd">    Returns:</span>
<span class="sd">        necessory_trips (set): trips needed to cover pareto-optimal journeys.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="sd">    rounds_desti_reached = list(set(rounds_desti_reached))</span>
<span class="sd">    if PRINT_ITINERARY == 1:</span>
<span class="sd">        _print_tbtr_journey_otm(J, Q, DESTINATION, SOURCE, footpath_dict, stops_dict, stoptimes_dict, d_time, MAX_TRANSFER, trip_transfer_dict,</span>
<span class="sd">                                rounds_desti_reached)</span>
<span class="sd">    necessory_trips = []</span>
<span class="sd">    for transfer_needed in reversed(rounds_desti_reached):</span>
<span class="sd">        no_of_transfer = transfer_needed</span>
<span class="sd">        current_trip = J[transfer_needed][1][0]</span>
<span class="sd">        journey = []</span>
<span class="sd">        while current_trip != 0:</span>
<span class="sd">            journey.append(current_trip)</span>
<span class="sd">            current_trip = [x for x in Q[no_of_transfer] if x[1] == current_trip][-1][-1][0]</span>
<span class="sd">            no_of_transfer = no_of_transfer - 1</span>
<span class="sd">        necessory_trips.extend(journey)</span>
<span class="sd">    return set(necessory_trips)</span>



<span class="sd">def onetomany_rtbtr(SOURCE: int, DESTINATION_LIST: list, d_time_groups, MAX_TRANSFER: int, WALKING_FROM_SOURCE: int,</span>
<span class="sd">                    PRINT_ITINERARY: int, OPTIMIZED: int, routes_by_stop_dict: dict, stops_dict: dict, stoptimes_dict: dict,</span>
<span class="sd">                    footpath_dict: dict, idx_by_route_stop_dict: dict, trip_transfer_dict: dict, trip_set: set) -&gt; list:</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="sd">    One to many rTBTR implementation</span>

<span class="sd">    Args:</span>
<span class="sd">        SOURCE (int): stop id of source stop.</span>
<span class="sd">        DESTINATION_LIST (list): list of stop ids of destination stop.</span>
<span class="sd">        d_time_groups (pandas.group): all possible departures times from all stops.</span>
<span class="sd">        MAX_TRANSFER (int): maximum transfer limit.</span>
<span class="sd">        WALKING_FROM_SOURCE (int): 1 or 0. 1 means walking from SOURCE is allowed.</span>
<span class="sd">        PRINT_ITINERARY (int): 1 or 0. 1 means print complete path.</span>
<span class="sd">        OPTIMIZED (int): 1 or 0. 1 means collect trips and 0 means collect routes.</span>
<span class="sd">        routes_by_stop_dict (dict): preprocessed dict. Format {stop_id: [id of routes passing through stop]}.</span>
<span class="sd">        stops_dict (dict): preprocessed dict. Format {route_id: [ids of stops in the route]}.</span>
<span class="sd">        stoptimes_dict (dict): preprocessed dict. Format {route_id: [[trip_1], [trip_2]]}.</span>
<span class="sd">        footpath_dict (dict): preprocessed dict. Format {from_stop_id: [(to_stop_id, footpath_time)]}.</span>
<span class="sd">        idx_by_route_stop_dict (dict): preprocessed dict. Format {(route id, stop id): stop index in route}.</span>
<span class="sd">        trip_transfer_dict (nested dict): keys: id of trip we are transferring from, value: {stop number: list of tuples</span>
<span class="sd">        of form (id of trip we are transferring to, stop number)}</span>
<span class="sd">        trip_set (set): set of trip ids from which trip-transfers are available.</span>

<span class="sd">    Returns:</span>
<span class="sd">        if OPTIMIZED==1:</span>
<span class="sd">            out (list):  list of trips required to cover all optimal journeys Format: [trip_id]</span>
<span class="sd">        elif OPTIMIZED==0:</span>
<span class="sd">            out (list):  list of routes required to cover all optimal journeys. Format: [route_id]</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="sd">    DESTINATION_LIST.remove(SOURCE)</span>
<span class="sd">    d_time_list = d_time_groups.get_group(SOURCE)[[&quot;trip_id&quot;, &#39;arrival_time&#39;, &#39;stop_sequence&#39;]].values.tolist()</span>
<span class="sd">    if WALKING_FROM_SOURCE == 1:</span>
<span class="sd">        try:</span>
<span class="sd">            source_footpaths = footpath_dict[SOURCE]</span>
<span class="sd">            for connection in source_footpaths:</span>
<span class="sd">                d_time_list.extend(d_time_groups.get_group(connection[0])[[&quot;trip_id&quot;, &#39;arrival_time&#39;, &#39;stop_sequence&#39;]].values.tolist())</span>
<span class="sd">        except KeyError:</span>
<span class="sd">            pass</span>
<span class="sd">    d_time_list.sort(key=lambda x: x[1], reverse=True)</span>

<span class="sd">    TP_list = []</span>
<span class="sd">    J, inf_time = initialize_onemany_tbtr(MAX_TRANSFER, DESTINATION_LIST)</span>
<span class="sd">    L = initialize_from_desti_onemany_tbtr(routes_by_stop_dict, stops_dict, DESTINATION_LIST, footpath_dict, idx_by_route_stop_dict)</span>
<span class="sd">    R_t = {x: defaultdict(lambda: 1000) for x in range(0, MAX_TRANSFER + 2)}  # assuming maximum route length is 1000</span>

<span class="sd">    for dep_details in d_time_list:</span>
<span class="sd">        rounds_desti_reached = {x: [] for x in DESTINATION_LIST}</span>
<span class="sd">        n = 1</span>
<span class="sd">        Q = initialize_from_source_range_tbtr(dep_details, MAX_TRANSFER, stoptimes_dict, R_t)</span>
<span class="sd">        dest_list_prime = DESTINATION_LIST.copy()</span>
<span class="sd">        while n &lt;= MAX_TRANSFER:</span>
<span class="sd">            stop_mark_dict = {stop: 0 for stop in dest_list_prime}</span>
<span class="sd">            scope = []</span>
<span class="sd">            for counter, trip_segment in enumerate(Q[n]):</span>
<span class="sd">                from_stop, tid, to_stop, trip_route, tid_idx = trip_segment[0: 5]</span>
<span class="sd">                trip = stoptimes_dict[trip_route][tid_idx][from_stop:to_stop]</span>
<span class="sd">                connection_list = []</span>
<span class="sd">                for desti in dest_list_prime:</span>
<span class="sd">                    try:</span>
<span class="sd">                        L[desti][trip_route]</span>
<span class="sd">                        stop_list, _ = zip(*trip)</span>
<span class="sd">                        for last_leg in L[desti][trip_route]:</span>
<span class="sd">                            idx = [x[0] for x in enumerate(stop_list) if x[1] == last_leg[2]]</span>
<span class="sd">                            if idx and from_stop &lt; last_leg[0] and trip[idx[0]][1] + last_leg[1] &lt; J[desti][n][0]:</span>
<span class="sd">                                if last_leg[1] == pd.to_timedelta(0, unit=&quot;seconds&quot;):</span>
<span class="sd">                                    walking = (0, 0)</span>
<span class="sd">                                else:</span>
<span class="sd">                                    walking = (1, stops_dict[trip_route][last_leg[0]])</span>
<span class="sd">                                J[desti] = update_label_tbtr(trip[idx[0]][1] + last_leg[1], n, (tid, walking, counter), J[desti], MAX_TRANSFER)</span>
<span class="sd">                                rounds_desti_reached[desti].append(n)</span>
<span class="sd">                    except KeyError:</span>
<span class="sd">                        pass</span>
<span class="sd">                    try:</span>
<span class="sd">                        if tid in trip_set and trip[1][1] &lt; J[desti][n][0]:</span>
<span class="sd">                            if stop_mark_dict[desti] == 0:</span>
<span class="sd">                                scope.append(desti)</span>
<span class="sd">                                stop_mark_dict[desti] = 1</span>
<span class="sd">                            connection_list.extend([connection for from_stop_idx, transfer_stop_id in enumerate(trip[1:], from_stop + 1)</span>
<span class="sd">                                                    for connection in trip_transfer_dict[tid][from_stop_idx]])</span>
<span class="sd">                    except IndexError:</span>
<span class="sd">                        pass</span>
<span class="sd">                connection_list = list(set(connection_list))</span>
<span class="sd">                enqueue_range_tbtr(connection_list, n + 1, (tid, counter, 0), R_t, Q, stoptimes_dict, MAX_TRANSFER)</span>
<span class="sd">            dest_list_prime = [*scope]</span>
<span class="sd">            n = n + 1</span>
<span class="sd">        for desti in DESTINATION_LIST:</span>
<span class="sd">            if rounds_desti_reached[desti]:</span>
<span class="sd">                TP_list.extend(</span>
<span class="sd">                    post_process_range_onemany_tbtr(J, Q, rounds_desti_reached[desti], PRINT_ITINERARY, desti, SOURCE, footpath_dict, stops_dict, stoptimes_dict,</span>
<span class="sd">                                               dep_details[1], MAX_TRANSFER, trip_transfer_dict))</span>
<span class="sd">    return TP_list</span>

<span class="sd">&quot;&quot;&quot;</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Transit-routing Pending documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Algorithms.TRANSFER_PATTERNS.transferpattern_func</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Prateek Agarwal, Tarun Rambha.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>